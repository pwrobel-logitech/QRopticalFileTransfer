

//returned status after we pass the qr image data
enum immediate_status {
    API_NOT_INITIALIZED = -1, // you must call the initialization function after release of resource
    NOT_RECOGNIZED = 0, // on the passed image, there were no detected qr image
    AMBUGUOUS = 1, // more than one qr image detected
    HEADER_ALREADY_DETECTED = 2,
    ERRONEUS_HASH_WRONG = 3,
    ERRONEUS = 4, // detected, but the frame number is wrong or missed too many frames
              // if received only once, the whole detection is revoked and resources must be released
    ERR_DATAFRAME_TOO_EARLY = 5, // got data frame, without recognizing the header first from previous frames
    RECOGNIZED = 6, // some qr code has been recognized for sure
    ALREADY_CORRECTLY_TRANSFERRED = 7,
    NOT_INITIALIZED = 8, // told to finish qr generation, but not even initialized before with the first frame
    LENGTH_QR_CHANGED = 9, //new QR frame has the new length - migh want to kill current transfer and start the new one
};


//
extern "C"{

// call this at the beginning of the usage
int initialize_decoder();

//set the path that will be used to flush the successfully decoded files to
int set_decoded_file_path(const char* path);

// send the next grayscale 8bit buffer with the QR image to the initialized decoder
// returned status indicates the information about what to do -
// for example when the ERRONEUS is received we must suspend any further decoding and deinitialize
// telling that the decoding of that pariticular file has failed
immediate_status send_next_grayscale_buffer_to_decoder(
        const char* grayscale_qr_data,
        int image_width,
        int image_height);


// execute this to inform the decoder that no further frames will be delivered for that particular file
// for sure
immediate_status tell_decoder_no_more_qr();


//-1 if header frame is still being generated by the decoder
// otherwise, this will return the total number of frames
// that the decoder will produce. This might be used to estimate the
// moment when the production of the frames has stopped
// (in case the very last frame has been omitted)
int get_total_frames_of_data_that_will_be_produced();

// those two can be used to estimate which frames are missing
// this can be used to create statistic about the current progress
// and the efficiency of the frame recognition
// -1 means no frame of given type has been processed so far
int get_last_number_of_frame_detected();
int get_last_number_of_header_frame_detected();


// call this at the end of the usage
int deinitialize_decoder();

}
